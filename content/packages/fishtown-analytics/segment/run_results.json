{"results": [{"node": {"raw_sql": "", "database": "claire", "schema": "dbt_claire", "fqn": ["segment_integration_tests", "example_segment_pages"], "unique_id": "seed.segment_integration_tests.example_segment_pages", "package_name": "segment_integration_tests", "root_path": "/Users/claire/fishtown/packages/segment/integration_tests", "path": "example_segment_pages.csv", "original_file_path": "data/example_segment_pages.csv", "name": "example_segment_pages", "resource_type": "seed", "alias": "example_segment_pages", "config": {"enabled": true, "materialized": "seed", "persist_docs": {}, "post-hook": [], "pre-hook": [], "vars": {}, "quoting": {}, "column_types": {}, "tags": []}, "tags": [], "refs": [], "sources": [], "depends_on": {"macros": [], "nodes": []}, "description": "", "columns": {}, "meta": {}, "docs": {"show": true}, "patch_path": null, "build_path": null, "compiled": true, "compiled_sql": "", "extra_ctes_injected": true, "extra_ctes": [], "injected_sql": "", "wrapped_sql": null, "seed_file_path": "/Users/claire/fishtown/packages/segment/integration_tests/data/example_segment_pages.csv"}, "error": null, "status": null, "execution_time": 0.015101194381713867, "thread_id": "Thread-1", "timing": [{"name": "compile", "started_at": "2020-03-26T18:15:27.121951Z", "completed_at": "2020-03-26T18:15:27.135905Z"}, {"name": "execute", "started_at": "2020-03-26T18:15:27.136284Z", "completed_at": "2020-03-26T18:15:27.136294Z"}], "fail": null, "warn": null, "skip": false}, {"node": {"raw_sql": "", "database": "claire", "schema": "dbt_claire", "fqn": ["segment", "referrer_mapping"], "unique_id": "seed.segment.referrer_mapping", "package_name": "segment", "root_path": "/Users/claire/fishtown/packages/segment/integration_tests/dbt_modules/segment", "path": "referrer_mapping.csv", "original_file_path": "data/referrer_mapping.csv", "name": "referrer_mapping", "resource_type": "seed", "alias": "referrer_mapping", "config": {"enabled": true, "materialized": "seed", "persist_docs": {}, "post-hook": [], "pre-hook": [], "vars": {}, "quoting": {}, "column_types": {}, "tags": []}, "tags": [], "refs": [], "sources": [], "depends_on": {"macros": [], "nodes": []}, "description": "", "columns": {}, "meta": {}, "docs": {"show": true}, "patch_path": null, "build_path": null, "compiled": true, "compiled_sql": "", "extra_ctes_injected": true, "extra_ctes": [], "injected_sql": "", "wrapped_sql": null, "seed_file_path": "/Users/claire/fishtown/packages/segment/integration_tests/dbt_modules/segment/data/referrer_mapping.csv"}, "error": null, "status": null, "execution_time": 0.00591588020324707, "thread_id": "Thread-1", "timing": [{"name": "compile", "started_at": "2020-03-26T18:15:27.137302Z", "completed_at": "2020-03-26T18:15:27.142342Z"}, {"name": "execute", "started_at": "2020-03-26T18:15:27.142586Z", "completed_at": "2020-03-26T18:15:27.142592Z"}], "fail": null, "warn": null, "skip": false}, {"node": {"raw_sql": "with source as (\n\n    select * from {{var('segment_page_views_table')}}\n    \n),\n\nrenamed as (\n\n    select\n    \n        id as page_view_id,\n        anonymous_id,\n        user_id,\n        \n        received_at as received_at_tstamp,\n        sent_at as sent_at_tstamp,\n        timestamp as tstamp,\n\n        url as page_url,\n        {{ dbt_utils.get_url_host('url') }} as page_url_host,\n        path as page_url_path,\n        title as page_title,\n        search as page_url_query,\n        \n        referrer,\n        replace(\n            {{ dbt_utils.get_url_host('referrer') }},\n            'www.',\n            ''\n        ) as referrer_host,\n\n        context_campaign_source as utm_source,\n        context_campaign_medium as utm_medium,\n        context_campaign_name as utm_campaign,\n        context_campaign_term as utm_term,\n        context_campaign_content as utm_content,\n        {{ dbt_utils.get_url_parameter('url', 'gclid') }} as gclid,\n        context_ip as ip,\n        context_user_agent as user_agent,\n        case\n            when lower(context_user_agent) like '%android%' then 'Android'\n            else replace(\n                {{ dbt_utils.split_part(dbt_utils.split_part('context_user_agent', \"'('\", 2), \"' '\", 1) }},\n                ';', '')\n        end as device\n        \n        {% if var('segment_pass_through_columns') != [] %}\n        ,\n        {{ var('segment_pass_through_columns') | join (\", \")}}\n        \n        {% endif %}\n                        \n    from source\n\n),\n\nfinal as (\n    \n    select\n        *,\n        case\n            when device = 'iPhone' then 'iPhone'\n            when device = 'Android' then 'Android'\n            when device in ('iPad', 'iPod') then 'Tablet'\n            when device in ('Windows', 'Macintosh', 'X11') then 'Desktop'\n            else 'Uncategorized'\n        end as device_category\n    from renamed\n\n)\n\nselect * from final", "database": "claire", "schema": "dbt_claire", "fqn": ["segment", "base", "segment_web_page_views"], "unique_id": "model.segment.segment_web_page_views", "package_name": "segment", "root_path": "/Users/claire/fishtown/packages/segment/integration_tests/dbt_modules/segment", "path": "base/segment_web_page_views.sql", "original_file_path": "models/base/segment_web_page_views.sql", "name": "segment_web_page_views", "resource_type": "model", "alias": "segment_web_page_views", "config": {"enabled": true, "materialized": "view", "persist_docs": {}, "post-hook": [], "pre-hook": [], "vars": {"segment_page_views_table": "{{ ref('example_segment_pages') }}", "segment_sessionization_trailing_window": 3, "segment_inactivity_cutoff": "30 * 60", "segment_pass_through_columns": []}, "quoting": {}, "column_types": {}, "tags": []}, "tags": [], "refs": [["example_segment_pages"]], "sources": [], "depends_on": {"macros": ["macro.dbt_utils.get_url_host", "macro.dbt_utils.get_url_parameter", "macro.dbt_utils.split_part"], "nodes": ["seed.segment_integration_tests.example_segment_pages"]}, "description": "This is a base model for Segment's web page views table. It does some straightforward renaming and parsing of Segment raw data in this table.", "columns": {"page_view_id": {"name": "page_view_id", "description": "", "meta": {}, "data_type": null, "tags": []}}, "meta": {}, "docs": {"show": true}, "patch_path": "models/base/schema.yml", "build_path": "target/compiled/segment/base/segment_web_page_views.sql", "compiled": true, "compiled_sql": "with source as (\n\n    select * from \"claire\".\"dbt_claire\".\"example_segment_pages\"\n    \n),\n\nrenamed as (\n\n    select\n    \n        id as page_view_id,\n        anonymous_id,\n        user_id,\n        \n        received_at as received_at_tstamp,\n        sent_at as sent_at_tstamp,\n        timestamp as tstamp,\n\n        url as page_url,\n        \n  \n    \n    cast(\n  \n\n    split_part(\n        \n  \n\n    split_part(\n        \n\n    replace(\n        \n\n    replace(\n        url,\n        'http://',\n        ''\n    )\n    \n\n\n,\n        'https://',\n        ''\n    )\n    \n\n\n,\n        '/',\n        1\n        )\n\n\n,\n        '?',\n        1\n        )\n\n\n as \n  varchar\n)\n\n as page_url_host,\n        path as page_url_path,\n        title as page_title,\n        search as page_url_query,\n        \n        referrer,\n        replace(\n            \n  \n    \n    cast(\n  \n\n    split_part(\n        \n  \n\n    split_part(\n        \n\n    replace(\n        \n\n    replace(\n        referrer,\n        'http://',\n        ''\n    )\n    \n\n\n,\n        'https://',\n        ''\n    )\n    \n\n\n,\n        '/',\n        1\n        )\n\n\n,\n        '?',\n        1\n        )\n\n\n as \n  varchar\n)\n\n,\n            'www.',\n            ''\n        ) as referrer_host,\n\n        context_campaign_source as utm_source,\n        context_campaign_medium as utm_medium,\n        context_campaign_name as utm_campaign,\n        context_campaign_term as utm_term,\n        context_campaign_content as utm_content,\n        nullif(\n  \n\n    split_part(\n        \n  \n\n    split_part(\n        url,\n        'gclid=',\n        2\n        )\n\n\n,\n        '&',\n        1\n        )\n\n\n,'') as gclid,\n        context_ip as ip,\n        context_user_agent as user_agent,\n        case\n            when lower(context_user_agent) like '%android%' then 'Android'\n            else replace(\n                \n  \n\n    split_part(\n        \n  \n\n    split_part(\n        context_user_agent,\n        '(',\n        2\n        )\n\n\n,\n        ' ',\n        1\n        )\n\n\n,\n                ';', '')\n        end as device\n        \n        \n                        \n    from source\n\n),\n\nfinal as (\n    \n    select\n        *,\n        case\n            when device = 'iPhone' then 'iPhone'\n            when device = 'Android' then 'Android'\n            when device in ('iPad', 'iPod') then 'Tablet'\n            when device in ('Windows', 'Macintosh', 'X11') then 'Desktop'\n            else 'Uncategorized'\n        end as device_category\n    from renamed\n\n)\n\nselect * from final", "extra_ctes_injected": true, "extra_ctes": [], "injected_sql": "with source as (\n\n    select * from \"claire\".\"dbt_claire\".\"example_segment_pages\"\n    \n),\n\nrenamed as (\n\n    select\n    \n        id as page_view_id,\n        anonymous_id,\n        user_id,\n        \n        received_at as received_at_tstamp,\n        sent_at as sent_at_tstamp,\n        timestamp as tstamp,\n\n        url as page_url,\n        \n  \n    \n    cast(\n  \n\n    split_part(\n        \n  \n\n    split_part(\n        \n\n    replace(\n        \n\n    replace(\n        url,\n        'http://',\n        ''\n    )\n    \n\n\n,\n        'https://',\n        ''\n    )\n    \n\n\n,\n        '/',\n        1\n        )\n\n\n,\n        '?',\n        1\n        )\n\n\n as \n  varchar\n)\n\n as page_url_host,\n        path as page_url_path,\n        title as page_title,\n        search as page_url_query,\n        \n        referrer,\n        replace(\n            \n  \n    \n    cast(\n  \n\n    split_part(\n        \n  \n\n    split_part(\n        \n\n    replace(\n        \n\n    replace(\n        referrer,\n        'http://',\n        ''\n    )\n    \n\n\n,\n        'https://',\n        ''\n    )\n    \n\n\n,\n        '/',\n        1\n        )\n\n\n,\n        '?',\n        1\n        )\n\n\n as \n  varchar\n)\n\n,\n            'www.',\n            ''\n        ) as referrer_host,\n\n        context_campaign_source as utm_source,\n        context_campaign_medium as utm_medium,\n        context_campaign_name as utm_campaign,\n        context_campaign_term as utm_term,\n        context_campaign_content as utm_content,\n        nullif(\n  \n\n    split_part(\n        \n  \n\n    split_part(\n        url,\n        'gclid=',\n        2\n        )\n\n\n,\n        '&',\n        1\n        )\n\n\n,'') as gclid,\n        context_ip as ip,\n        context_user_agent as user_agent,\n        case\n            when lower(context_user_agent) like '%android%' then 'Android'\n            else replace(\n                \n  \n\n    split_part(\n        \n  \n\n    split_part(\n        context_user_agent,\n        '(',\n        2\n        )\n\n\n,\n        ' ',\n        1\n        )\n\n\n,\n                ';', '')\n        end as device\n        \n        \n                        \n    from source\n\n),\n\nfinal as (\n    \n    select\n        *,\n        case\n            when device = 'iPhone' then 'iPhone'\n            when device = 'Android' then 'Android'\n            when device in ('iPad', 'iPod') then 'Tablet'\n            when device in ('Windows', 'Macintosh', 'X11') then 'Desktop'\n            else 'Uncategorized'\n        end as device_category\n    from renamed\n\n)\n\nselect * from final", "wrapped_sql": null}, "error": null, "status": null, "execution_time": 0.02626514434814453, "thread_id": "Thread-1", "timing": [{"name": "compile", "started_at": "2020-03-26T18:15:27.143759Z", "completed_at": "2020-03-26T18:15:27.168784Z"}, {"name": "execute", "started_at": "2020-03-26T18:15:27.169167Z", "completed_at": "2020-03-26T18:15:27.169177Z"}], "fail": null, "warn": null, "skip": false}, {"node": {"raw_sql": "{{ config(\n    materialized = 'incremental',\n    unique_key = 'page_view_id',\n    sort = 'tstamp',\n    dist = 'page_view_id'\n) }}\n\n{#\nthe initial CTE in this model is unusually complicated; its function is to\nselect all pageviews (for all time) for users who have pageviews since the\nmodel was most recently run. there are many window functions in this model so\nin order to appropriately calculate all of them we need each user's entire\npage view history, but we only want to grab that for users who have page view\nevents we need to calculate.\n#}\n\nwith pageviews as (\n\n    select * from {{ref('segment_web_page_views')}}\n\n    {% if is_incremental() %}\n    where anonymous_id in (\n        select distinct anonymous_id\n        from {{ref('segment_web_page_views')}}\n        where cast(tstamp as datetime) >= (\n          select\n            {{ dbt_utils.dateadd(\n                'hour',\n                -var('segment_sessionization_trailing_window'),\n                'max(tstamp)'\n            ) }}\n          from {{ this }})\n        )\n    {% endif %}\n\n),\n\nnumbered as (\n\n    --This CTE is responsible for assigning an all-time page view number for a\n    --given anonymous_id. We don't need to do this across devices because the\n    --whole point of this field is for sessionization, and sessions can't span\n    --multiple devices.\n\n    select\n\n        *,\n\n        row_number() over (\n            partition by anonymous_id\n            order by tstamp\n            ) as page_view_number\n\n    from pageviews\n\n),\n\nlagged as (\n\n    --This CTE is responsible for simply grabbing the last value of `tstamp`.\n    --We'll use this downstream to do timestamp math--it's how we determine the\n    --period of inactivity.\n\n    select\n\n        *,\n\n        lag(tstamp) over (\n            partition by anonymous_id\n            order by page_view_number\n            ) as previous_tstamp\n\n    from numbered\n\n),\n\ndiffed as (\n\n    --This CTE simply calculates `period_of_inactivity`.\n\n    select\n        *,\n        {{ dbt_utils.datediff('previous_tstamp', 'tstamp', 'second') }} as period_of_inactivity\n    from lagged\n\n),\n\nnew_sessions as (\n\n    --This CTE calculates a single 1/0 field--if the period of inactivity prior\n    --to this page view was greater than 30 minutes, the value is 1, otherwise\n    --it's 0. We'll use this to calculate the user's session #.\n\n    select\n        *,\n        case\n            when period_of_inactivity <= {{var('segment_inactivity_cutoff')}} then 0\n            else 1\n        end as new_session\n    from diffed\n\n),\n\nsession_numbers as (\n\n    --This CTE calculates a user's session (1, 2, 3) number from `new_session`.\n    --This single field is the entire point of the entire prior series of\n    --calculations.\n\n    select\n\n        *,\n\n        sum(new_session) over (\n            partition by anonymous_id\n            order by page_view_number\n            rows between unbounded preceding and current row\n            ) as session_number\n\n    from new_sessions\n\n),\n\nsession_ids as (\n\n    --This CTE assigns a globally unique session id based on the combination of\n    --`anonymous_id` and `session_number`.\n\n    select\n\n        {{dbt_utils.star(ref('segment_web_page_views'))}},\n        page_view_number,\n        {{dbt_utils.surrogate_key('anonymous_id', 'session_number')}} as session_id\n\n    from session_numbers\n\n)\n\nselect * from session_ids", "database": "claire", "schema": "dbt_claire", "fqn": ["segment", "sessionization", "segment_web_page_views__sessionized"], "unique_id": "model.segment.segment_web_page_views__sessionized", "package_name": "segment", "root_path": "/Users/claire/fishtown/packages/segment/integration_tests/dbt_modules/segment", "path": "sessionization/segment_web_page_views__sessionized.sql", "original_file_path": "models/sessionization/segment_web_page_views__sessionized.sql", "name": "segment_web_page_views__sessionized", "resource_type": "model", "alias": "segment_web_page_views__sessionized", "config": {"enabled": true, "materialized": "incremental", "persist_docs": {}, "post-hook": [], "pre-hook": [], "vars": {"segment_page_views_table": "{{ ref('example_segment_pages') }}", "segment_sessionization_trailing_window": 3, "segment_inactivity_cutoff": "30 * 60", "segment_pass_through_columns": []}, "quoting": {}, "column_types": {}, "tags": [], "unique_key": "page_view_id", "sort": "tstamp", "dist": "page_view_id"}, "tags": [], "refs": [["segment_web_page_views"], ["segment_web_page_views"]], "sources": [], "depends_on": {"macros": ["macro.dbt.is_incremental", "macro.dbt_utils.datediff", "macro.dbt_utils.star", "macro.dbt_utils.surrogate_key", "macro.dbt_utils.dateadd"], "nodes": ["model.segment.segment_web_page_views", "model.segment.segment_web_page_views"]}, "description": "The purpose of this model is to assign a `session_id` to page views. The business logic of how this is done is that any period of inactivity of 30 minutes or more resets the session, and any subsequent page views are assigned a new `session_id`.\n\nThe implementation of this logic is rather involved, and requires multiple CTEs. Comments have been added to the source to describe the purpose of the CTEs that are more esoteric.", "columns": {"page_view_id": {"name": "page_view_id", "description": "", "meta": {}, "data_type": null, "tags": []}}, "meta": {}, "docs": {"show": true}, "patch_path": "models/sessionization/schema.yml", "build_path": "target/compiled/segment/sessionization/segment_web_page_views__sessionized.sql", "compiled": true, "compiled_sql": "\n\n\n\nwith pageviews as (\n\n    select * from \"claire\".\"dbt_claire\".\"segment_web_page_views\"\n\n    \n    where anonymous_id in (\n        select distinct anonymous_id\n        from \"claire\".\"dbt_claire\".\"segment_web_page_views\"\n        where cast(tstamp as datetime) >= (\n          select\n            \n  \n\n    dateadd(\n        hour,\n        -3,\n        max(tstamp)\n        )\n\n\n\n          from \"claire\".\"dbt_claire\".\"segment_web_page_views__sessionized\")\n        )\n    \n\n),\n\nnumbered as (\n\n    --This CTE is responsible for assigning an all-time page view number for a\n    --given anonymous_id. We don't need to do this across devices because the\n    --whole point of this field is for sessionization, and sessions can't span\n    --multiple devices.\n\n    select\n\n        *,\n\n        row_number() over (\n            partition by anonymous_id\n            order by tstamp\n            ) as page_view_number\n\n    from pageviews\n\n),\n\nlagged as (\n\n    --This CTE is responsible for simply grabbing the last value of `tstamp`.\n    --We'll use this downstream to do timestamp math--it's how we determine the\n    --period of inactivity.\n\n    select\n\n        *,\n\n        lag(tstamp) over (\n            partition by anonymous_id\n            order by page_view_number\n            ) as previous_tstamp\n\n    from numbered\n\n),\n\ndiffed as (\n\n    --This CTE simply calculates `period_of_inactivity`.\n\n    select\n        *,\n        \n  \n\n    datediff(\n        second,\n        previous_tstamp,\n        tstamp\n        )\n\n\n as period_of_inactivity\n    from lagged\n\n),\n\nnew_sessions as (\n\n    --This CTE calculates a single 1/0 field--if the period of inactivity prior\n    --to this page view was greater than 30 minutes, the value is 1, otherwise\n    --it's 0. We'll use this to calculate the user's session #.\n\n    select\n        *,\n        case\n            when period_of_inactivity <= 30 * 60 then 0\n            else 1\n        end as new_session\n    from diffed\n\n),\n\nsession_numbers as (\n\n    --This CTE calculates a user's session (1, 2, 3) number from `new_session`.\n    --This single field is the entire point of the entire prior series of\n    --calculations.\n\n    select\n\n        *,\n\n        sum(new_session) over (\n            partition by anonymous_id\n            order by page_view_number\n            rows between unbounded preceding and current row\n            ) as session_number\n\n    from new_sessions\n\n),\n\nsession_ids as (\n\n    --This CTE assigns a globally unique session id based on the combination of\n    --`anonymous_id` and `session_number`.\n\n    select\n\n        \"page_view_id\",\n\"anonymous_id\",\n\"user_id\",\n\"received_at_tstamp\",\n\"sent_at_tstamp\",\n\"tstamp\",\n\"page_url\",\n\"page_url_host\",\n\"page_url_path\",\n\"page_title\",\n\"page_url_query\",\n\"referrer\",\n\"referrer_host\",\n\"utm_source\",\n\"utm_medium\",\n\"utm_campaign\",\n\"utm_term\",\n\"utm_content\",\n\"gclid\",\n\"ip\",\n\"user_agent\",\n\"device\",\n\"device_category\",\n        page_view_number,\n        \n\n    \n        \n    \n\n    md5(cast(\n  \n    \n    coalesce(cast(anonymous_id as \n  varchar\n), '') || '-' || coalesce(cast(session_number as \n  varchar\n), '')\n\n\n as \n  varchar\n)) as session_id\n\n    from session_numbers\n\n)\n\nselect * from session_ids", "extra_ctes_injected": true, "extra_ctes": [], "injected_sql": "\n\n\n\nwith pageviews as (\n\n    select * from \"claire\".\"dbt_claire\".\"segment_web_page_views\"\n\n    \n    where anonymous_id in (\n        select distinct anonymous_id\n        from \"claire\".\"dbt_claire\".\"segment_web_page_views\"\n        where cast(tstamp as datetime) >= (\n          select\n            \n  \n\n    dateadd(\n        hour,\n        -3,\n        max(tstamp)\n        )\n\n\n\n          from \"claire\".\"dbt_claire\".\"segment_web_page_views__sessionized\")\n        )\n    \n\n),\n\nnumbered as (\n\n    --This CTE is responsible for assigning an all-time page view number for a\n    --given anonymous_id. We don't need to do this across devices because the\n    --whole point of this field is for sessionization, and sessions can't span\n    --multiple devices.\n\n    select\n\n        *,\n\n        row_number() over (\n            partition by anonymous_id\n            order by tstamp\n            ) as page_view_number\n\n    from pageviews\n\n),\n\nlagged as (\n\n    --This CTE is responsible for simply grabbing the last value of `tstamp`.\n    --We'll use this downstream to do timestamp math--it's how we determine the\n    --period of inactivity.\n\n    select\n\n        *,\n\n        lag(tstamp) over (\n            partition by anonymous_id\n            order by page_view_number\n            ) as previous_tstamp\n\n    from numbered\n\n),\n\ndiffed as (\n\n    --This CTE simply calculates `period_of_inactivity`.\n\n    select\n        *,\n        \n  \n\n    datediff(\n        second,\n        previous_tstamp,\n        tstamp\n        )\n\n\n as period_of_inactivity\n    from lagged\n\n),\n\nnew_sessions as (\n\n    --This CTE calculates a single 1/0 field--if the period of inactivity prior\n    --to this page view was greater than 30 minutes, the value is 1, otherwise\n    --it's 0. We'll use this to calculate the user's session #.\n\n    select\n        *,\n        case\n            when period_of_inactivity <= 30 * 60 then 0\n            else 1\n        end as new_session\n    from diffed\n\n),\n\nsession_numbers as (\n\n    --This CTE calculates a user's session (1, 2, 3) number from `new_session`.\n    --This single field is the entire point of the entire prior series of\n    --calculations.\n\n    select\n\n        *,\n\n        sum(new_session) over (\n            partition by anonymous_id\n            order by page_view_number\n            rows between unbounded preceding and current row\n            ) as session_number\n\n    from new_sessions\n\n),\n\nsession_ids as (\n\n    --This CTE assigns a globally unique session id based on the combination of\n    --`anonymous_id` and `session_number`.\n\n    select\n\n        \"page_view_id\",\n\"anonymous_id\",\n\"user_id\",\n\"received_at_tstamp\",\n\"sent_at_tstamp\",\n\"tstamp\",\n\"page_url\",\n\"page_url_host\",\n\"page_url_path\",\n\"page_title\",\n\"page_url_query\",\n\"referrer\",\n\"referrer_host\",\n\"utm_source\",\n\"utm_medium\",\n\"utm_campaign\",\n\"utm_term\",\n\"utm_content\",\n\"gclid\",\n\"ip\",\n\"user_agent\",\n\"device\",\n\"device_category\",\n        page_view_number,\n        \n\n    \n        \n    \n\n    md5(cast(\n  \n    \n    coalesce(cast(anonymous_id as \n  varchar\n), '') || '-' || coalesce(cast(session_number as \n  varchar\n), '')\n\n\n as \n  varchar\n)) as session_id\n\n    from session_numbers\n\n)\n\nselect * from session_ids", "wrapped_sql": null}, "error": null, "status": null, "execution_time": 0.9965970516204834, "thread_id": "Thread-1", "timing": [{"name": "compile", "started_at": "2020-03-26T18:15:27.170473Z", "completed_at": "2020-03-26T18:15:28.127696Z"}, {"name": "execute", "started_at": "2020-03-26T18:15:28.128047Z", "completed_at": "2020-03-26T18:15:28.128056Z"}], "fail": null, "warn": null, "skip": false}, {"node": {"raw_sql": "{{ config(\n    materialized = 'table'\n) }}\n\nwith events as (\n\n    select * from {{ref('segment_web_page_views')}}\n\n),\n\nmapping as (\n\n    select distinct\n    \n        anonymous_id, \n\n        last_value(user_id ignore nulls) over (\n            partition by anonymous_id \n            order by tstamp \n            rows between unbounded preceding and unbounded following\n        ) as user_id,\n\n        min(tstamp) over (\n            partition by anonymous_id\n        ) as first_seen_at,\n\n        max(tstamp) over (\n            partition by anonymous_id\n        ) as last_seen_at\n\n    from events\n\n)\n\nselect * from mapping", "database": "claire", "schema": "dbt_claire", "fqn": ["segment", "sessionization", "segment_web_user_stitching"], "unique_id": "model.segment.segment_web_user_stitching", "package_name": "segment", "root_path": "/Users/claire/fishtown/packages/segment/integration_tests/dbt_modules/segment", "path": "sessionization/segment_web_user_stitching.sql", "original_file_path": "models/sessionization/segment_web_user_stitching.sql", "name": "segment_web_user_stitching", "resource_type": "model", "alias": "segment_web_user_stitching", "config": {"enabled": true, "materialized": "table", "persist_docs": {}, "post-hook": [], "pre-hook": [], "vars": {"segment_page_views_table": "{{ ref('example_segment_pages') }}", "segment_sessionization_trailing_window": 3, "segment_inactivity_cutoff": "30 * 60", "segment_pass_through_columns": []}, "quoting": {}, "column_types": {}, "tags": []}, "tags": [], "refs": [["segment_web_page_views"]], "sources": [], "depends_on": {"macros": [], "nodes": ["model.segment.segment_web_page_views"]}, "description": "This model performs \"user stitching\" on top of web event data. User stitching is the process of tying all events associated with a cookie to the same user_id, and solves a common problem in event analytics that users are only identified part way through their activity stream. This model returns a single user_id for every anonymous_id, and is later joined in to build a `blended_user_id` field, that acts as the primary user identifier for all sessions.", "columns": {"anonymous_id": {"name": "anonymous_id", "description": "", "meta": {}, "data_type": null, "tags": []}}, "meta": {}, "docs": {"show": true}, "patch_path": "models/sessionization/schema.yml", "build_path": "target/compiled/segment/sessionization/segment_web_user_stitching.sql", "compiled": true, "compiled_sql": "\n\nwith events as (\n\n    select * from \"claire\".\"dbt_claire\".\"segment_web_page_views\"\n\n),\n\nmapping as (\n\n    select distinct\n    \n        anonymous_id, \n\n        last_value(user_id ignore nulls) over (\n            partition by anonymous_id \n            order by tstamp \n            rows between unbounded preceding and unbounded following\n        ) as user_id,\n\n        min(tstamp) over (\n            partition by anonymous_id\n        ) as first_seen_at,\n\n        max(tstamp) over (\n            partition by anonymous_id\n        ) as last_seen_at\n\n    from events\n\n)\n\nselect * from mapping", "extra_ctes_injected": true, "extra_ctes": [], "injected_sql": "\n\nwith events as (\n\n    select * from \"claire\".\"dbt_claire\".\"segment_web_page_views\"\n\n),\n\nmapping as (\n\n    select distinct\n    \n        anonymous_id, \n\n        last_value(user_id ignore nulls) over (\n            partition by anonymous_id \n            order by tstamp \n            rows between unbounded preceding and unbounded following\n        ) as user_id,\n\n        min(tstamp) over (\n            partition by anonymous_id\n        ) as first_seen_at,\n\n        max(tstamp) over (\n            partition by anonymous_id\n        ) as last_seen_at\n\n    from events\n\n)\n\nselect * from mapping", "wrapped_sql": null}, "error": null, "status": null, "execution_time": 0.015035867691040039, "thread_id": "Thread-1", "timing": [{"name": "compile", "started_at": "2020-03-26T18:15:28.169027Z", "completed_at": "2020-03-26T18:15:28.182175Z"}, {"name": "execute", "started_at": "2020-03-26T18:15:28.182489Z", "completed_at": "2020-03-26T18:15:28.182499Z"}], "fail": null, "warn": null, "skip": false}, {"node": {"raw_sql": "{{ config(severity='ERROR') }}{{ test_not_null(model=ref('segment_web_page_views'), column_name='page_view_id') }}", "database": "claire", "schema": "dbt_claire", "fqn": ["segment", "schema_test", "not_null_segment_web_page_views_page_view_id"], "unique_id": "test.segment.not_null_segment_web_page_views_page_view_id", "package_name": "segment", "root_path": "/Users/claire/fishtown/packages/segment/integration_tests/dbt_modules/segment", "path": "schema_test/not_null_segment_web_page_views_page_view_id.sql", "original_file_path": "models/base/schema.yml", "name": "not_null_segment_web_page_views_page_view_id", "resource_type": "test", "alias": "not_null_segment_web_page_views_page_view_id", "config": {"enabled": true, "materialized": "view", "persist_docs": {}, "post-hook": [], "pre-hook": [], "vars": {"segment_page_views_table": "{{ ref('example_segment_pages') }}", "segment_sessionization_trailing_window": 3, "segment_inactivity_cutoff": "30 * 60", "segment_pass_through_columns": []}, "quoting": {}, "column_types": {}, "tags": [], "severity": "ERROR"}, "tags": ["schema"], "refs": [["segment_web_page_views"]], "sources": [], "depends_on": {"macros": ["macro.dbt.test_not_null"], "nodes": ["model.segment.segment_web_page_views"]}, "description": "", "columns": {}, "meta": {}, "docs": {"show": true}, "patch_path": null, "build_path": "target/compiled/segment/schema_test/not_null_segment_web_page_views_page_view_id.sql", "compiled": true, "compiled_sql": "\n\n\n\nselect count(*)\nfrom \"claire\".\"dbt_claire\".\"segment_web_page_views\"\nwhere page_view_id is null\n\n", "extra_ctes_injected": true, "extra_ctes": [], "injected_sql": "\n\n\n\nselect count(*)\nfrom \"claire\".\"dbt_claire\".\"segment_web_page_views\"\nwhere page_view_id is null\n\n", "wrapped_sql": "\n\n\n\nselect count(*)\nfrom \"claire\".\"dbt_claire\".\"segment_web_page_views\"\nwhere page_view_id is null\n\n", "column_name": "page_view_id", "test_metadata": {"namespace": null, "name": "not_null", "kwargs": {"column_name": "page_view_id"}}}, "error": null, "status": null, "execution_time": 0.02077794075012207, "thread_id": "Thread-1", "timing": [{"name": "compile", "started_at": "2020-03-26T18:15:28.183614Z", "completed_at": "2020-03-26T18:15:28.203221Z"}, {"name": "execute", "started_at": "2020-03-26T18:15:28.203610Z", "completed_at": "2020-03-26T18:15:28.203620Z"}], "fail": null, "warn": null, "skip": false}, {"node": {"raw_sql": "{{ config(severity='ERROR') }}{{ test_unique(model=ref('segment_web_page_views'), column_name='page_view_id') }}", "database": "claire", "schema": "dbt_claire", "fqn": ["segment", "schema_test", "unique_segment_web_page_views_page_view_id"], "unique_id": "test.segment.unique_segment_web_page_views_page_view_id", "package_name": "segment", "root_path": "/Users/claire/fishtown/packages/segment/integration_tests/dbt_modules/segment", "path": "schema_test/unique_segment_web_page_views_page_view_id.sql", "original_file_path": "models/base/schema.yml", "name": "unique_segment_web_page_views_page_view_id", "resource_type": "test", "alias": "unique_segment_web_page_views_page_view_id", "config": {"enabled": true, "materialized": "view", "persist_docs": {}, "post-hook": [], "pre-hook": [], "vars": {"segment_page_views_table": "{{ ref('example_segment_pages') }}", "segment_sessionization_trailing_window": 3, "segment_inactivity_cutoff": "30 * 60", "segment_pass_through_columns": []}, "quoting": {}, "column_types": {}, "tags": [], "severity": "ERROR"}, "tags": ["schema"], "refs": [["segment_web_page_views"]], "sources": [], "depends_on": {"macros": ["macro.dbt.test_unique"], "nodes": ["model.segment.segment_web_page_views"]}, "description": "", "columns": {}, "meta": {}, "docs": {"show": true}, "patch_path": null, "build_path": "target/compiled/segment/schema_test/unique_segment_web_page_views_page_view_id.sql", "compiled": true, "compiled_sql": "\n\n\n\nselect count(*)\nfrom (\n\n    select\n        page_view_id\n\n    from \"claire\".\"dbt_claire\".\"segment_web_page_views\"\n    where page_view_id is not null\n    group by page_view_id\n    having count(*) > 1\n\n) validation_errors\n\n", "extra_ctes_injected": true, "extra_ctes": [], "injected_sql": "\n\n\n\nselect count(*)\nfrom (\n\n    select\n        page_view_id\n\n    from \"claire\".\"dbt_claire\".\"segment_web_page_views\"\n    where page_view_id is not null\n    group by page_view_id\n    having count(*) > 1\n\n) validation_errors\n\n", "wrapped_sql": "\n\n\n\nselect count(*)\nfrom (\n\n    select\n        page_view_id\n\n    from \"claire\".\"dbt_claire\".\"segment_web_page_views\"\n    where page_view_id is not null\n    group by page_view_id\n    having count(*) > 1\n\n) validation_errors\n\n", "column_name": "page_view_id", "test_metadata": {"namespace": null, "name": "unique", "kwargs": {"column_name": "page_view_id"}}}, "error": null, "status": null, "execution_time": 0.011564016342163086, "thread_id": "Thread-1", "timing": [{"name": "compile", "started_at": "2020-03-26T18:15:28.204642Z", "completed_at": "2020-03-26T18:15:28.214871Z"}, {"name": "execute", "started_at": "2020-03-26T18:15:28.215375Z", "completed_at": "2020-03-26T18:15:28.215386Z"}], "fail": null, "warn": null, "skip": false}, {"node": {"raw_sql": "{{ config(\n    materialized = 'incremental',\n    unique_key = 'session_id',\n    sort = 'session_start_tstamp',\n    dist = 'session_id'\n) }}\n\n{% set partition_by = \"partition by session_id\" %}\n\n{% set window_clause = \"\n    partition by session_id\n    order by page_view_number\n    rows between unbounded preceding and unbounded following\n    \" %}\n\n{% set first_values = {\n    'utm_source' : 'utm_source',\n    'utm_content' : 'utm_content',\n    'utm_medium' : 'utm_medium',\n    'utm_campaign' : 'utm_campaign',\n    'utm_term' : 'utm_term',\n    'gclid' : 'gclid',\n    'page_url' : 'first_page_url',\n    'page_url_host' : 'first_page_url_host',\n    'page_url_path' : 'first_page_url_path',\n    'page_url_query' : 'first_page_url_query',\n    'referrer' : 'referrer',\n    'referrer_host' : 'referrer_host',\n    'device' : 'device',\n    'device_category' : 'device_category'\n    } %}\n\n{% set last_values = {\n    'page_url' : 'last_page_url',\n    'page_url_host' : 'last_page_url_host',\n    'page_url_path' : 'last_page_url_path',\n    'page_url_query' : 'last_page_url_query'\n    } %}\n\n{% for col in var('segment_pass_through_columns') %}\n    {% do first_values.update({col: 'first_' ~ col}) %}\n    {% do last_values.update({col: 'last_' ~ col}) %}\n{% endfor %}\n\nwith pageviews_sessionized as (\n\n    select * from {{ref('segment_web_page_views__sessionized')}}\n\n    {% if is_incremental() %}\n        where cast(tstamp as datetime) > (\n          select\n            {{ dbt_utils.dateadd(\n                'hour',\n                -var('segment_sessionization_trailing_window'),\n                'max(session_start_tstamp)'\n            ) }}\n          from {{ this }})\n    {% endif %}\n\n),\n\nreferrer_mapping as (\n\n    select * from {{ ref('referrer_mapping') }}\n\n),\n\nagg as (\n\n    select distinct\n\n        session_id,\n        anonymous_id,\n        min(tstamp) over ( {{partition_by}} ) as session_start_tstamp,\n        max(tstamp) over ( {{partition_by}} ) as session_end_tstamp,\n        count(*) over ( {{partition_by}} ) as page_views,\n\n        {% for (key, value) in first_values.items() %}\n        first_value({{key}}) over ({{window_clause}}) as {{value}},\n        {% endfor %}\n\n        {% for (key, value) in last_values.items() %}\n        last_value({{key}}) over ({{window_clause}}) as {{value}}{% if not loop.last %},{% endif %}\n        {% endfor %}\n\n    from pageviews_sessionized\n\n),\n\ndiffs as (\n\n    select\n\n        *,\n\n        {{ dbt_utils.datediff('session_start_tstamp', 'session_end_tstamp', 'second') }} as duration_in_s\n\n    from agg\n\n),\n\ntiers as (\n\n    select\n\n        *,\n\n        case\n            when duration_in_s between 0 and 9 then '0s to 9s'\n            when duration_in_s between 10 and 29 then '10s to 29s'\n            when duration_in_s between 30 and 59 then '30s to 59s'\n            when duration_in_s > 59 then '60s or more'\n            else null\n        end as duration_in_s_tier\n\n    from diffs\n\n),\n\nmapped as (\n\n    select\n        tiers.*,\n        referrer_mapping.medium as referrer_medium,\n        referrer_mapping.source as referrer_source\n\n    from tiers\n\n    left join referrer_mapping on tiers.referrer_host = referrer_mapping.host\n\n)\n\nselect * from mapped", "database": "claire", "schema": "dbt_claire", "fqn": ["segment", "sessionization", "segment_web_sessions__initial"], "unique_id": "model.segment.segment_web_sessions__initial", "package_name": "segment", "root_path": "/Users/claire/fishtown/packages/segment/integration_tests/dbt_modules/segment", "path": "sessionization/segment_web_sessions__initial.sql", "original_file_path": "models/sessionization/segment_web_sessions__initial.sql", "name": "segment_web_sessions__initial", "resource_type": "model", "alias": "segment_web_sessions__initial", "config": {"enabled": true, "materialized": "incremental", "persist_docs": {}, "post-hook": [], "pre-hook": [], "vars": {"segment_page_views_table": "{{ ref('example_segment_pages') }}", "segment_sessionization_trailing_window": 3, "segment_inactivity_cutoff": "30 * 60", "segment_pass_through_columns": []}, "quoting": {}, "column_types": {}, "tags": [], "unique_key": "session_id", "sort": "session_start_tstamp", "dist": "session_id"}, "tags": [], "refs": [["segment_web_page_views__sessionized"], ["referrer_mapping"]], "sources": [], "depends_on": {"macros": ["macro.dbt.is_incremental", "macro.dbt_utils.datediff", "macro.dbt_utils.dateadd"], "nodes": ["model.segment.segment_web_page_views__sessionized", "seed.segment.referrer_mapping"]}, "description": "This model performs the aggregation of page views into sessions. The `session_id` having already been calculated in `segment_web_page_views__sessionized`, this model simply calls a bunch of window functions to grab the first or last value of a given field and store it at the session level.", "columns": {"session_id": {"name": "session_id", "description": "", "meta": {}, "data_type": null, "tags": []}}, "meta": {}, "docs": {"show": true}, "patch_path": "models/sessionization/schema.yml", "build_path": "target/compiled/segment/sessionization/segment_web_sessions__initial.sql", "compiled": true, "compiled_sql": "\n\n\n\n\n\n\n\n\n\n\n\nwith pageviews_sessionized as (\n\n    select * from \"claire\".\"dbt_claire\".\"segment_web_page_views__sessionized\"\n\n    \n        where cast(tstamp as datetime) > (\n          select\n            \n  \n\n    dateadd(\n        hour,\n        -3,\n        max(session_start_tstamp)\n        )\n\n\n\n          from \"claire\".\"dbt_claire\".\"segment_web_sessions__initial\")\n    \n\n),\n\nreferrer_mapping as (\n\n    select * from \"claire\".\"dbt_claire\".\"referrer_mapping\"\n\n),\n\nagg as (\n\n    select distinct\n\n        session_id,\n        anonymous_id,\n        min(tstamp) over ( partition by session_id ) as session_start_tstamp,\n        max(tstamp) over ( partition by session_id ) as session_end_tstamp,\n        count(*) over ( partition by session_id ) as page_views,\n\n        \n        first_value(utm_source) over (\n    partition by session_id\n    order by page_view_number\n    rows between unbounded preceding and unbounded following\n    ) as utm_source,\n        \n        first_value(utm_content) over (\n    partition by session_id\n    order by page_view_number\n    rows between unbounded preceding and unbounded following\n    ) as utm_content,\n        \n        first_value(utm_medium) over (\n    partition by session_id\n    order by page_view_number\n    rows between unbounded preceding and unbounded following\n    ) as utm_medium,\n        \n        first_value(utm_campaign) over (\n    partition by session_id\n    order by page_view_number\n    rows between unbounded preceding and unbounded following\n    ) as utm_campaign,\n        \n        first_value(utm_term) over (\n    partition by session_id\n    order by page_view_number\n    rows between unbounded preceding and unbounded following\n    ) as utm_term,\n        \n        first_value(gclid) over (\n    partition by session_id\n    order by page_view_number\n    rows between unbounded preceding and unbounded following\n    ) as gclid,\n        \n        first_value(page_url) over (\n    partition by session_id\n    order by page_view_number\n    rows between unbounded preceding and unbounded following\n    ) as first_page_url,\n        \n        first_value(page_url_host) over (\n    partition by session_id\n    order by page_view_number\n    rows between unbounded preceding and unbounded following\n    ) as first_page_url_host,\n        \n        first_value(page_url_path) over (\n    partition by session_id\n    order by page_view_number\n    rows between unbounded preceding and unbounded following\n    ) as first_page_url_path,\n        \n        first_value(page_url_query) over (\n    partition by session_id\n    order by page_view_number\n    rows between unbounded preceding and unbounded following\n    ) as first_page_url_query,\n        \n        first_value(referrer) over (\n    partition by session_id\n    order by page_view_number\n    rows between unbounded preceding and unbounded following\n    ) as referrer,\n        \n        first_value(referrer_host) over (\n    partition by session_id\n    order by page_view_number\n    rows between unbounded preceding and unbounded following\n    ) as referrer_host,\n        \n        first_value(device) over (\n    partition by session_id\n    order by page_view_number\n    rows between unbounded preceding and unbounded following\n    ) as device,\n        \n        first_value(device_category) over (\n    partition by session_id\n    order by page_view_number\n    rows between unbounded preceding and unbounded following\n    ) as device_category,\n        \n\n        \n        last_value(page_url) over (\n    partition by session_id\n    order by page_view_number\n    rows between unbounded preceding and unbounded following\n    ) as last_page_url,\n        \n        last_value(page_url_host) over (\n    partition by session_id\n    order by page_view_number\n    rows between unbounded preceding and unbounded following\n    ) as last_page_url_host,\n        \n        last_value(page_url_path) over (\n    partition by session_id\n    order by page_view_number\n    rows between unbounded preceding and unbounded following\n    ) as last_page_url_path,\n        \n        last_value(page_url_query) over (\n    partition by session_id\n    order by page_view_number\n    rows between unbounded preceding and unbounded following\n    ) as last_page_url_query\n        \n\n    from pageviews_sessionized\n\n),\n\ndiffs as (\n\n    select\n\n        *,\n\n        \n  \n\n    datediff(\n        second,\n        session_start_tstamp,\n        session_end_tstamp\n        )\n\n\n as duration_in_s\n\n    from agg\n\n),\n\ntiers as (\n\n    select\n\n        *,\n\n        case\n            when duration_in_s between 0 and 9 then '0s to 9s'\n            when duration_in_s between 10 and 29 then '10s to 29s'\n            when duration_in_s between 30 and 59 then '30s to 59s'\n            when duration_in_s > 59 then '60s or more'\n            else null\n        end as duration_in_s_tier\n\n    from diffs\n\n),\n\nmapped as (\n\n    select\n        tiers.*,\n        referrer_mapping.medium as referrer_medium,\n        referrer_mapping.source as referrer_source\n\n    from tiers\n\n    left join referrer_mapping on tiers.referrer_host = referrer_mapping.host\n\n)\n\nselect * from mapped", "extra_ctes_injected": true, "extra_ctes": [], "injected_sql": "\n\n\n\n\n\n\n\n\n\n\n\nwith pageviews_sessionized as (\n\n    select * from \"claire\".\"dbt_claire\".\"segment_web_page_views__sessionized\"\n\n    \n        where cast(tstamp as datetime) > (\n          select\n            \n  \n\n    dateadd(\n        hour,\n        -3,\n        max(session_start_tstamp)\n        )\n\n\n\n          from \"claire\".\"dbt_claire\".\"segment_web_sessions__initial\")\n    \n\n),\n\nreferrer_mapping as (\n\n    select * from \"claire\".\"dbt_claire\".\"referrer_mapping\"\n\n),\n\nagg as (\n\n    select distinct\n\n        session_id,\n        anonymous_id,\n        min(tstamp) over ( partition by session_id ) as session_start_tstamp,\n        max(tstamp) over ( partition by session_id ) as session_end_tstamp,\n        count(*) over ( partition by session_id ) as page_views,\n\n        \n        first_value(utm_source) over (\n    partition by session_id\n    order by page_view_number\n    rows between unbounded preceding and unbounded following\n    ) as utm_source,\n        \n        first_value(utm_content) over (\n    partition by session_id\n    order by page_view_number\n    rows between unbounded preceding and unbounded following\n    ) as utm_content,\n        \n        first_value(utm_medium) over (\n    partition by session_id\n    order by page_view_number\n    rows between unbounded preceding and unbounded following\n    ) as utm_medium,\n        \n        first_value(utm_campaign) over (\n    partition by session_id\n    order by page_view_number\n    rows between unbounded preceding and unbounded following\n    ) as utm_campaign,\n        \n        first_value(utm_term) over (\n    partition by session_id\n    order by page_view_number\n    rows between unbounded preceding and unbounded following\n    ) as utm_term,\n        \n        first_value(gclid) over (\n    partition by session_id\n    order by page_view_number\n    rows between unbounded preceding and unbounded following\n    ) as gclid,\n        \n        first_value(page_url) over (\n    partition by session_id\n    order by page_view_number\n    rows between unbounded preceding and unbounded following\n    ) as first_page_url,\n        \n        first_value(page_url_host) over (\n    partition by session_id\n    order by page_view_number\n    rows between unbounded preceding and unbounded following\n    ) as first_page_url_host,\n        \n        first_value(page_url_path) over (\n    partition by session_id\n    order by page_view_number\n    rows between unbounded preceding and unbounded following\n    ) as first_page_url_path,\n        \n        first_value(page_url_query) over (\n    partition by session_id\n    order by page_view_number\n    rows between unbounded preceding and unbounded following\n    ) as first_page_url_query,\n        \n        first_value(referrer) over (\n    partition by session_id\n    order by page_view_number\n    rows between unbounded preceding and unbounded following\n    ) as referrer,\n        \n        first_value(referrer_host) over (\n    partition by session_id\n    order by page_view_number\n    rows between unbounded preceding and unbounded following\n    ) as referrer_host,\n        \n        first_value(device) over (\n    partition by session_id\n    order by page_view_number\n    rows between unbounded preceding and unbounded following\n    ) as device,\n        \n        first_value(device_category) over (\n    partition by session_id\n    order by page_view_number\n    rows between unbounded preceding and unbounded following\n    ) as device_category,\n        \n\n        \n        last_value(page_url) over (\n    partition by session_id\n    order by page_view_number\n    rows between unbounded preceding and unbounded following\n    ) as last_page_url,\n        \n        last_value(page_url_host) over (\n    partition by session_id\n    order by page_view_number\n    rows between unbounded preceding and unbounded following\n    ) as last_page_url_host,\n        \n        last_value(page_url_path) over (\n    partition by session_id\n    order by page_view_number\n    rows between unbounded preceding and unbounded following\n    ) as last_page_url_path,\n        \n        last_value(page_url_query) over (\n    partition by session_id\n    order by page_view_number\n    rows between unbounded preceding and unbounded following\n    ) as last_page_url_query\n        \n\n    from pageviews_sessionized\n\n),\n\ndiffs as (\n\n    select\n\n        *,\n\n        \n  \n\n    datediff(\n        second,\n        session_start_tstamp,\n        session_end_tstamp\n        )\n\n\n as duration_in_s\n\n    from agg\n\n),\n\ntiers as (\n\n    select\n\n        *,\n\n        case\n            when duration_in_s between 0 and 9 then '0s to 9s'\n            when duration_in_s between 10 and 29 then '10s to 29s'\n            when duration_in_s between 30 and 59 then '30s to 59s'\n            when duration_in_s > 59 then '60s or more'\n            else null\n        end as duration_in_s_tier\n\n    from diffs\n\n),\n\nmapped as (\n\n    select\n        tiers.*,\n        referrer_mapping.medium as referrer_medium,\n        referrer_mapping.source as referrer_source\n\n    from tiers\n\n    left join referrer_mapping on tiers.referrer_host = referrer_mapping.host\n\n)\n\nselect * from mapped", "wrapped_sql": null}, "error": null, "status": null, "execution_time": 0.26470088958740234, "thread_id": "Thread-1", "timing": [{"name": "compile", "started_at": "2020-03-26T18:15:28.216681Z", "completed_at": "2020-03-26T18:15:28.443045Z"}, {"name": "execute", "started_at": "2020-03-26T18:15:28.443467Z", "completed_at": "2020-03-26T18:15:28.443477Z"}], "fail": null, "warn": null, "skip": false}, {"node": {"raw_sql": "{{ config(severity='ERROR') }}{{ test_not_null(model=ref('segment_web_page_views__sessionized'), column_name='page_view_id') }}", "database": "claire", "schema": "dbt_claire", "fqn": ["segment", "schema_test", "not_null_segment_web_page_views__sessionized_page_view_id"], "unique_id": "test.segment.not_null_segment_web_page_views__sessionized_page_view_id", "package_name": "segment", "root_path": "/Users/claire/fishtown/packages/segment/integration_tests/dbt_modules/segment", "path": "schema_test/not_null_segment_web_page_views__sessionized_page_view_id.sql", "original_file_path": "models/sessionization/schema.yml", "name": "not_null_segment_web_page_views__sessionized_page_view_id", "resource_type": "test", "alias": "not_null_segment_web_page_views__sessionized_page_view_id", "config": {"enabled": true, "materialized": "view", "persist_docs": {}, "post-hook": [], "pre-hook": [], "vars": {"segment_page_views_table": "{{ ref('example_segment_pages') }}", "segment_sessionization_trailing_window": 3, "segment_inactivity_cutoff": "30 * 60", "segment_pass_through_columns": []}, "quoting": {}, "column_types": {}, "tags": [], "severity": "ERROR"}, "tags": ["schema"], "refs": [["segment_web_page_views__sessionized"]], "sources": [], "depends_on": {"macros": ["macro.dbt.test_not_null"], "nodes": ["model.segment.segment_web_page_views__sessionized"]}, "description": "", "columns": {}, "meta": {}, "docs": {"show": true}, "patch_path": null, "build_path": "target/compiled/segment/schema_test/not_null_segment_web_page_views__sessionized_page_view_id.sql", "compiled": true, "compiled_sql": "\n\n\n\nselect count(*)\nfrom \"claire\".\"dbt_claire\".\"segment_web_page_views__sessionized\"\nwhere page_view_id is null\n\n", "extra_ctes_injected": true, "extra_ctes": [], "injected_sql": "\n\n\n\nselect count(*)\nfrom \"claire\".\"dbt_claire\".\"segment_web_page_views__sessionized\"\nwhere page_view_id is null\n\n", "wrapped_sql": "\n\n\n\nselect count(*)\nfrom \"claire\".\"dbt_claire\".\"segment_web_page_views__sessionized\"\nwhere page_view_id is null\n\n", "column_name": "page_view_id", "test_metadata": {"namespace": null, "name": "not_null", "kwargs": {"column_name": "page_view_id"}}}, "error": null, "status": null, "execution_time": 0.014523029327392578, "thread_id": "Thread-1", "timing": [{"name": "compile", "started_at": "2020-03-26T18:15:28.483267Z", "completed_at": "2020-03-26T18:15:28.495715Z"}, {"name": "execute", "started_at": "2020-03-26T18:15:28.496041Z", "completed_at": "2020-03-26T18:15:28.496051Z"}], "fail": null, "warn": null, "skip": false}, {"node": {"raw_sql": "{{ config(severity='ERROR') }}{{ test_unique(model=ref('segment_web_page_views__sessionized'), column_name='page_view_id') }}", "database": "claire", "schema": "dbt_claire", "fqn": ["segment", "schema_test", "unique_segment_web_page_views__sessionized_page_view_id"], "unique_id": "test.segment.unique_segment_web_page_views__sessionized_page_view_id", "package_name": "segment", "root_path": "/Users/claire/fishtown/packages/segment/integration_tests/dbt_modules/segment", "path": "schema_test/unique_segment_web_page_views__sessionized_page_view_id.sql", "original_file_path": "models/sessionization/schema.yml", "name": "unique_segment_web_page_views__sessionized_page_view_id", "resource_type": "test", "alias": "unique_segment_web_page_views__sessionized_page_view_id", "config": {"enabled": true, "materialized": "view", "persist_docs": {}, "post-hook": [], "pre-hook": [], "vars": {"segment_page_views_table": "{{ ref('example_segment_pages') }}", "segment_sessionization_trailing_window": 3, "segment_inactivity_cutoff": "30 * 60", "segment_pass_through_columns": []}, "quoting": {}, "column_types": {}, "tags": [], "severity": "ERROR"}, "tags": ["schema"], "refs": [["segment_web_page_views__sessionized"]], "sources": [], "depends_on": {"macros": ["macro.dbt.test_unique"], "nodes": ["model.segment.segment_web_page_views__sessionized"]}, "description": "", "columns": {}, "meta": {}, "docs": {"show": true}, "patch_path": null, "build_path": "target/compiled/segment/schema_test/unique_segment_web_page_views__sessionized_page_view_id.sql", "compiled": true, "compiled_sql": "\n\n\n\nselect count(*)\nfrom (\n\n    select\n        page_view_id\n\n    from \"claire\".\"dbt_claire\".\"segment_web_page_views__sessionized\"\n    where page_view_id is not null\n    group by page_view_id\n    having count(*) > 1\n\n) validation_errors\n\n", "extra_ctes_injected": true, "extra_ctes": [], "injected_sql": "\n\n\n\nselect count(*)\nfrom (\n\n    select\n        page_view_id\n\n    from \"claire\".\"dbt_claire\".\"segment_web_page_views__sessionized\"\n    where page_view_id is not null\n    group by page_view_id\n    having count(*) > 1\n\n) validation_errors\n\n", "wrapped_sql": "\n\n\n\nselect count(*)\nfrom (\n\n    select\n        page_view_id\n\n    from \"claire\".\"dbt_claire\".\"segment_web_page_views__sessionized\"\n    where page_view_id is not null\n    group by page_view_id\n    having count(*) > 1\n\n) validation_errors\n\n", "column_name": "page_view_id", "test_metadata": {"namespace": null, "name": "unique", "kwargs": {"column_name": "page_view_id"}}}, "error": null, "status": null, "execution_time": 0.010787010192871094, "thread_id": "Thread-1", "timing": [{"name": "compile", "started_at": "2020-03-26T18:15:28.497320Z", "completed_at": "2020-03-26T18:15:28.506776Z"}, {"name": "execute", "started_at": "2020-03-26T18:15:28.507109Z", "completed_at": "2020-03-26T18:15:28.507120Z"}], "fail": null, "warn": null, "skip": false}, {"node": {"raw_sql": "{{ config(severity='ERROR') }}{{ test_not_null(model=ref('segment_web_user_stitching'), column_name='anonymous_id') }}", "database": "claire", "schema": "dbt_claire", "fqn": ["segment", "schema_test", "not_null_segment_web_user_stitching_anonymous_id"], "unique_id": "test.segment.not_null_segment_web_user_stitching_anonymous_id", "package_name": "segment", "root_path": "/Users/claire/fishtown/packages/segment/integration_tests/dbt_modules/segment", "path": "schema_test/not_null_segment_web_user_stitching_anonymous_id.sql", "original_file_path": "models/sessionization/schema.yml", "name": "not_null_segment_web_user_stitching_anonymous_id", "resource_type": "test", "alias": "not_null_segment_web_user_stitching_anonymous_id", "config": {"enabled": true, "materialized": "view", "persist_docs": {}, "post-hook": [], "pre-hook": [], "vars": {"segment_page_views_table": "{{ ref('example_segment_pages') }}", "segment_sessionization_trailing_window": 3, "segment_inactivity_cutoff": "30 * 60", "segment_pass_through_columns": []}, "quoting": {}, "column_types": {}, "tags": [], "severity": "ERROR"}, "tags": ["schema"], "refs": [["segment_web_user_stitching"]], "sources": [], "depends_on": {"macros": ["macro.dbt.test_not_null"], "nodes": ["model.segment.segment_web_user_stitching"]}, "description": "", "columns": {}, "meta": {}, "docs": {"show": true}, "patch_path": null, "build_path": "target/compiled/segment/schema_test/not_null_segment_web_user_stitching_anonymous_id.sql", "compiled": true, "compiled_sql": "\n\n\n\nselect count(*)\nfrom \"claire\".\"dbt_claire\".\"segment_web_user_stitching\"\nwhere anonymous_id is null\n\n", "extra_ctes_injected": true, "extra_ctes": [], "injected_sql": "\n\n\n\nselect count(*)\nfrom \"claire\".\"dbt_claire\".\"segment_web_user_stitching\"\nwhere anonymous_id is null\n\n", "wrapped_sql": "\n\n\n\nselect count(*)\nfrom \"claire\".\"dbt_claire\".\"segment_web_user_stitching\"\nwhere anonymous_id is null\n\n", "column_name": "anonymous_id", "test_metadata": {"namespace": null, "name": "not_null", "kwargs": {"column_name": "anonymous_id"}}}, "error": null, "status": null, "execution_time": 0.011167049407958984, "thread_id": "Thread-1", "timing": [{"name": "compile", "started_at": "2020-03-26T18:15:28.508242Z", "completed_at": "2020-03-26T18:15:28.518296Z"}, {"name": "execute", "started_at": "2020-03-26T18:15:28.518629Z", "completed_at": "2020-03-26T18:15:28.518638Z"}], "fail": null, "warn": null, "skip": false}, {"node": {"raw_sql": "{{ config(severity='ERROR') }}{{ test_unique(model=ref('segment_web_user_stitching'), column_name='anonymous_id') }}", "database": "claire", "schema": "dbt_claire", "fqn": ["segment", "schema_test", "unique_segment_web_user_stitching_anonymous_id"], "unique_id": "test.segment.unique_segment_web_user_stitching_anonymous_id", "package_name": "segment", "root_path": "/Users/claire/fishtown/packages/segment/integration_tests/dbt_modules/segment", "path": "schema_test/unique_segment_web_user_stitching_anonymous_id.sql", "original_file_path": "models/sessionization/schema.yml", "name": "unique_segment_web_user_stitching_anonymous_id", "resource_type": "test", "alias": "unique_segment_web_user_stitching_anonymous_id", "config": {"enabled": true, "materialized": "view", "persist_docs": {}, "post-hook": [], "pre-hook": [], "vars": {"segment_page_views_table": "{{ ref('example_segment_pages') }}", "segment_sessionization_trailing_window": 3, "segment_inactivity_cutoff": "30 * 60", "segment_pass_through_columns": []}, "quoting": {}, "column_types": {}, "tags": [], "severity": "ERROR"}, "tags": ["schema"], "refs": [["segment_web_user_stitching"]], "sources": [], "depends_on": {"macros": ["macro.dbt.test_unique"], "nodes": ["model.segment.segment_web_user_stitching"]}, "description": "", "columns": {}, "meta": {}, "docs": {"show": true}, "patch_path": null, "build_path": "target/compiled/segment/schema_test/unique_segment_web_user_stitching_anonymous_id.sql", "compiled": true, "compiled_sql": "\n\n\n\nselect count(*)\nfrom (\n\n    select\n        anonymous_id\n\n    from \"claire\".\"dbt_claire\".\"segment_web_user_stitching\"\n    where anonymous_id is not null\n    group by anonymous_id\n    having count(*) > 1\n\n) validation_errors\n\n", "extra_ctes_injected": true, "extra_ctes": [], "injected_sql": "\n\n\n\nselect count(*)\nfrom (\n\n    select\n        anonymous_id\n\n    from \"claire\".\"dbt_claire\".\"segment_web_user_stitching\"\n    where anonymous_id is not null\n    group by anonymous_id\n    having count(*) > 1\n\n) validation_errors\n\n", "wrapped_sql": "\n\n\n\nselect count(*)\nfrom (\n\n    select\n        anonymous_id\n\n    from \"claire\".\"dbt_claire\".\"segment_web_user_stitching\"\n    where anonymous_id is not null\n    group by anonymous_id\n    having count(*) > 1\n\n) validation_errors\n\n", "column_name": "anonymous_id", "test_metadata": {"namespace": null, "name": "unique", "kwargs": {"column_name": "anonymous_id"}}}, "error": null, "status": null, "execution_time": 0.011361122131347656, "thread_id": "Thread-1", "timing": [{"name": "compile", "started_at": "2020-03-26T18:15:28.519776Z", "completed_at": "2020-03-26T18:15:28.529599Z"}, {"name": "execute", "started_at": "2020-03-26T18:15:28.530196Z", "completed_at": "2020-03-26T18:15:28.530209Z"}], "fail": null, "warn": null, "skip": false}, {"node": {"raw_sql": "{{ config(\n    materialized = 'incremental',\n    unique_key = 'session_id',\n    sort = 'session_start_tstamp',\n    dist = 'session_id'\n) }}\n\nwith sessions as (\n\n    select * from {{ref('segment_web_sessions__initial')}}\n\n    {% if is_incremental() %}\n        where cast(session_start_tstamp as datetime) > (\n          select\n            {{ dbt_utils.dateadd(\n                'hour',\n                -var('segment_sessionization_trailing_window'),\n                'max(session_start_tstamp)'\n            ) }}\n          from {{ this }})\n    {% endif %}\n\n),\n\nid_stitching as (\n\n    select * from {{ref('segment_web_user_stitching')}}\n\n),\n\njoined as (\n\n    select\n\n        sessions.*,\n\n        coalesce(id_stitching.user_id, sessions.anonymous_id)\n            as blended_user_id\n\n    from sessions\n    left join id_stitching using (anonymous_id)\n\n)\n\nselect * from joined", "database": "claire", "schema": "dbt_claire", "fqn": ["segment", "sessionization", "segment_web_sessions__stitched"], "unique_id": "model.segment.segment_web_sessions__stitched", "package_name": "segment", "root_path": "/Users/claire/fishtown/packages/segment/integration_tests/dbt_modules/segment", "path": "sessionization/segment_web_sessions__stitched.sql", "original_file_path": "models/sessionization/segment_web_sessions__stitched.sql", "name": "segment_web_sessions__stitched", "resource_type": "model", "alias": "segment_web_sessions__stitched", "config": {"enabled": true, "materialized": "incremental", "persist_docs": {}, "post-hook": [], "pre-hook": [], "vars": {"segment_page_views_table": "{{ ref('example_segment_pages') }}", "segment_sessionization_trailing_window": 3, "segment_inactivity_cutoff": "30 * 60", "segment_pass_through_columns": []}, "quoting": {}, "column_types": {}, "tags": [], "unique_key": "session_id", "sort": "session_start_tstamp", "dist": "session_id"}, "tags": [], "refs": [["segment_web_sessions__initial"], ["segment_web_user_stitching"]], "sources": [], "depends_on": {"macros": ["macro.dbt.is_incremental", "macro.dbt_utils.dateadd"], "nodes": ["model.segment.segment_web_sessions__initial", "model.segment.segment_web_user_stitching"]}, "description": "This model joins initial session data with user stitching to get the field `blended_user_id`, the id for a user across all devices that they can be identified on. This logic is broken out from other models because, while incremental, it will frequently need to be rebuilt from scratch: this is because the user stitching process can change the `blended_user_id` values for historical sessions.\n\nIt is recommended to typically run this model in its default configuration (incrementally) but on some regular basis to do a `dbt run --full-refresh --models segment_web_sessions__stitched+` so that this model and downstream models get rebuilt.", "columns": {"session_id": {"name": "session_id", "description": "", "meta": {}, "data_type": null, "tags": []}}, "meta": {}, "docs": {"show": true}, "patch_path": "models/sessionization/schema.yml", "build_path": "target/compiled/segment/sessionization/segment_web_sessions__stitched.sql", "compiled": true, "compiled_sql": "\n\nwith sessions as (\n\n    select * from \"claire\".\"dbt_claire\".\"segment_web_sessions__initial\"\n\n    \n        where cast(session_start_tstamp as datetime) > (\n          select\n            \n  \n\n    dateadd(\n        hour,\n        -3,\n        max(session_start_tstamp)\n        )\n\n\n\n          from \"claire\".\"dbt_claire\".\"segment_web_sessions__stitched\")\n    \n\n),\n\nid_stitching as (\n\n    select * from \"claire\".\"dbt_claire\".\"segment_web_user_stitching\"\n\n),\n\njoined as (\n\n    select\n\n        sessions.*,\n\n        coalesce(id_stitching.user_id, sessions.anonymous_id)\n            as blended_user_id\n\n    from sessions\n    left join id_stitching using (anonymous_id)\n\n)\n\nselect * from joined", "extra_ctes_injected": true, "extra_ctes": [], "injected_sql": "\n\nwith sessions as (\n\n    select * from \"claire\".\"dbt_claire\".\"segment_web_sessions__initial\"\n\n    \n        where cast(session_start_tstamp as datetime) > (\n          select\n            \n  \n\n    dateadd(\n        hour,\n        -3,\n        max(session_start_tstamp)\n        )\n\n\n\n          from \"claire\".\"dbt_claire\".\"segment_web_sessions__stitched\")\n    \n\n),\n\nid_stitching as (\n\n    select * from \"claire\".\"dbt_claire\".\"segment_web_user_stitching\"\n\n),\n\njoined as (\n\n    select\n\n        sessions.*,\n\n        coalesce(id_stitching.user_id, sessions.anonymous_id)\n            as blended_user_id\n\n    from sessions\n    left join id_stitching using (anonymous_id)\n\n)\n\nselect * from joined", "wrapped_sql": null}, "error": null, "status": null, "execution_time": 0.24422192573547363, "thread_id": "Thread-1", "timing": [{"name": "compile", "started_at": "2020-03-26T18:15:28.531364Z", "completed_at": "2020-03-26T18:15:28.738197Z"}, {"name": "execute", "started_at": "2020-03-26T18:15:28.738431Z", "completed_at": "2020-03-26T18:15:28.738439Z"}], "fail": null, "warn": null, "skip": false}, {"node": {"raw_sql": "{{ config(severity='ERROR') }}{{ test_not_null(model=ref('segment_web_sessions__initial'), column_name='session_id') }}", "database": "claire", "schema": "dbt_claire", "fqn": ["segment", "schema_test", "not_null_segment_web_sessions__initial_session_id"], "unique_id": "test.segment.not_null_segment_web_sessions__initial_session_id", "package_name": "segment", "root_path": "/Users/claire/fishtown/packages/segment/integration_tests/dbt_modules/segment", "path": "schema_test/not_null_segment_web_sessions__initial_session_id.sql", "original_file_path": "models/sessionization/schema.yml", "name": "not_null_segment_web_sessions__initial_session_id", "resource_type": "test", "alias": "not_null_segment_web_sessions__initial_session_id", "config": {"enabled": true, "materialized": "view", "persist_docs": {}, "post-hook": [], "pre-hook": [], "vars": {"segment_page_views_table": "{{ ref('example_segment_pages') }}", "segment_sessionization_trailing_window": 3, "segment_inactivity_cutoff": "30 * 60", "segment_pass_through_columns": []}, "quoting": {}, "column_types": {}, "tags": [], "severity": "ERROR"}, "tags": ["schema"], "refs": [["segment_web_sessions__initial"]], "sources": [], "depends_on": {"macros": ["macro.dbt.test_not_null"], "nodes": ["model.segment.segment_web_sessions__initial"]}, "description": "", "columns": {}, "meta": {}, "docs": {"show": true}, "patch_path": null, "build_path": "target/compiled/segment/schema_test/not_null_segment_web_sessions__initial_session_id.sql", "compiled": true, "compiled_sql": "\n\n\n\nselect count(*)\nfrom \"claire\".\"dbt_claire\".\"segment_web_sessions__initial\"\nwhere session_id is null\n\n", "extra_ctes_injected": true, "extra_ctes": [], "injected_sql": "\n\n\n\nselect count(*)\nfrom \"claire\".\"dbt_claire\".\"segment_web_sessions__initial\"\nwhere session_id is null\n\n", "wrapped_sql": "\n\n\n\nselect count(*)\nfrom \"claire\".\"dbt_claire\".\"segment_web_sessions__initial\"\nwhere session_id is null\n\n", "column_name": "session_id", "test_metadata": {"namespace": null, "name": "not_null", "kwargs": {"column_name": "session_id"}}}, "error": null, "status": null, "execution_time": 0.01094508171081543, "thread_id": "Thread-1", "timing": [{"name": "compile", "started_at": "2020-03-26T18:15:28.776480Z", "completed_at": "2020-03-26T18:15:28.786166Z"}, {"name": "execute", "started_at": "2020-03-26T18:15:28.786500Z", "completed_at": "2020-03-26T18:15:28.786508Z"}], "fail": null, "warn": null, "skip": false}, {"node": {"raw_sql": "{{ config(severity='ERROR') }}{{ test_unique(model=ref('segment_web_sessions__initial'), column_name='session_id') }}", "database": "claire", "schema": "dbt_claire", "fqn": ["segment", "schema_test", "unique_segment_web_sessions__initial_session_id"], "unique_id": "test.segment.unique_segment_web_sessions__initial_session_id", "package_name": "segment", "root_path": "/Users/claire/fishtown/packages/segment/integration_tests/dbt_modules/segment", "path": "schema_test/unique_segment_web_sessions__initial_session_id.sql", "original_file_path": "models/sessionization/schema.yml", "name": "unique_segment_web_sessions__initial_session_id", "resource_type": "test", "alias": "unique_segment_web_sessions__initial_session_id", "config": {"enabled": true, "materialized": "view", "persist_docs": {}, "post-hook": [], "pre-hook": [], "vars": {"segment_page_views_table": "{{ ref('example_segment_pages') }}", "segment_sessionization_trailing_window": 3, "segment_inactivity_cutoff": "30 * 60", "segment_pass_through_columns": []}, "quoting": {}, "column_types": {}, "tags": [], "severity": "ERROR"}, "tags": ["schema"], "refs": [["segment_web_sessions__initial"]], "sources": [], "depends_on": {"macros": ["macro.dbt.test_unique"], "nodes": ["model.segment.segment_web_sessions__initial"]}, "description": "", "columns": {}, "meta": {}, "docs": {"show": true}, "patch_path": null, "build_path": "target/compiled/segment/schema_test/unique_segment_web_sessions__initial_session_id.sql", "compiled": true, "compiled_sql": "\n\n\n\nselect count(*)\nfrom (\n\n    select\n        session_id\n\n    from \"claire\".\"dbt_claire\".\"segment_web_sessions__initial\"\n    where session_id is not null\n    group by session_id\n    having count(*) > 1\n\n) validation_errors\n\n", "extra_ctes_injected": true, "extra_ctes": [], "injected_sql": "\n\n\n\nselect count(*)\nfrom (\n\n    select\n        session_id\n\n    from \"claire\".\"dbt_claire\".\"segment_web_sessions__initial\"\n    where session_id is not null\n    group by session_id\n    having count(*) > 1\n\n) validation_errors\n\n", "wrapped_sql": "\n\n\n\nselect count(*)\nfrom (\n\n    select\n        session_id\n\n    from \"claire\".\"dbt_claire\".\"segment_web_sessions__initial\"\n    where session_id is not null\n    group by session_id\n    having count(*) > 1\n\n) validation_errors\n\n", "column_name": "session_id", "test_metadata": {"namespace": null, "name": "unique", "kwargs": {"column_name": "session_id"}}}, "error": null, "status": null, "execution_time": 0.009370803833007812, "thread_id": "Thread-1", "timing": [{"name": "compile", "started_at": "2020-03-26T18:15:28.787488Z", "completed_at": "2020-03-26T18:15:28.795869Z"}, {"name": "execute", "started_at": "2020-03-26T18:15:28.796141Z", "completed_at": "2020-03-26T18:15:28.796148Z"}], "fail": null, "warn": null, "skip": false}, {"node": {"raw_sql": "{{ config(\n    materialized = 'incremental',\n    unique_key = 'session_id',\n    sort = 'session_start_tstamp',\n    dist = 'session_id'\n) }}\n\n{% set sessionization_cutoff %}\n(\n    select\n        {{ dbt_utils.dateadd(\n            'hour',\n            -var('segment_sessionization_trailing_window'),\n            'max(session_start_tstamp)'\n        ) }}\n    from {{this}}\n)\n{% endset %}\n\n{#\nWindow functions are challenging to make incremental. This approach grabs\nexisting values from the existing table and then adds the value of session_number\non top of that seed. During development, this decreased the model runtime\nby 25x on 2 years of data (from 600 to 25 seconds), so even though the code is\nmore complicated, the performance tradeoff is worth it.\n#}\n\nwith sessions as (\n\n    select * from {{ref('segment_web_sessions__stitched')}}\n\n    {% if is_incremental() %}\n    where cast(session_start_tstamp as datetime) > {{sessionization_cutoff}}\n    {% endif %}\n\n),\n\n{% if is_incremental() %}\n\nagg as (\n\n    select\n        blended_user_id,\n        count(*) as starting_session_number\n    from {{this}}\n\n    -- only include sessions that are not going to be resessionized in this run\n    where cast(session_start_tstamp as datetime) <= {{sessionization_cutoff}}\n\n    group by 1\n\n),\n\n{% endif %}\n\nwindowed as (\n\n    select\n\n        *,\n\n        row_number() over (\n            partition by blended_user_id\n            order by sessions.session_start_tstamp\n            )\n            {% if is_incremental() %}+ coalesce(agg.starting_session_number, 0) {% endif %}\n            as session_number\n\n    from sessions\n\n    {% if is_incremental() %}\n    left join agg using (blended_user_id)\n    {% endif %}\n\n\n)\n\nselect * from windowed", "database": "claire", "schema": "dbt_claire", "fqn": ["segment", "sessionization", "segment_web_sessions"], "unique_id": "model.segment.segment_web_sessions", "package_name": "segment", "root_path": "/Users/claire/fishtown/packages/segment/integration_tests/dbt_modules/segment", "path": "sessionization/segment_web_sessions.sql", "original_file_path": "models/sessionization/segment_web_sessions.sql", "name": "segment_web_sessions", "resource_type": "model", "alias": "segment_web_sessions", "config": {"enabled": true, "materialized": "incremental", "persist_docs": {}, "post-hook": [], "pre-hook": [], "vars": {"segment_page_views_table": "{{ ref('example_segment_pages') }}", "segment_sessionization_trailing_window": 3, "segment_inactivity_cutoff": "30 * 60", "segment_pass_through_columns": []}, "quoting": {}, "column_types": {}, "tags": [], "unique_key": "session_id", "sort": "session_start_tstamp", "dist": "session_id"}, "tags": [], "refs": [["segment_web_sessions__stitched"]], "sources": [], "depends_on": {"macros": ["macro.dbt_utils.dateadd", "macro.dbt.is_incremental"], "nodes": ["model.segment.segment_web_sessions__stitched"]}, "description": "The purpose of this model is to expose a single web session, derived from Segment web events. Sessions are the most common way that analysis of web visitor behavior is conducted, and although Segment doesn't natively output session data, this model uses standard logic to create sessions out of page view events. \n\nA session is meant to represent a single instance of web activity where a user is actively browsing a website. In this case, we are demarcating sessions by 30 minute windows of inactivity: if there is 30 minutes of inactivity between two page views, the second page view begins a new session. Additionally, page views across different devices will always be tied to different sessions.\n\nThe logic implemented in this particular model is responsible for incrementally calculating a user's session number; the core sessionization logic is done in upstream models.", "columns": {"session_id": {"name": "session_id", "description": "", "meta": {}, "data_type": null, "tags": []}}, "meta": {}, "docs": {"show": true}, "patch_path": "models/sessionization/schema.yml", "build_path": "target/compiled/segment/sessionization/segment_web_sessions.sql", "compiled": true, "compiled_sql": "\n\n\n\n\n\nwith sessions as (\n\n    select * from \"claire\".\"dbt_claire\".\"segment_web_sessions__stitched\"\n\n    \n    where cast(session_start_tstamp as datetime) > \n(\n    select\n        \n  \n\n    dateadd(\n        hour,\n        -3,\n        max(session_start_tstamp)\n        )\n\n\n\n    from \"claire\".\"dbt_claire\".\"segment_web_sessions\"\n)\n\n    \n\n),\n\n\n\nagg as (\n\n    select\n        blended_user_id,\n        count(*) as starting_session_number\n    from \"claire\".\"dbt_claire\".\"segment_web_sessions\"\n\n    -- only include sessions that are not going to be resessionized in this run\n    where cast(session_start_tstamp as datetime) <= \n(\n    select\n        \n  \n\n    dateadd(\n        hour,\n        -3,\n        max(session_start_tstamp)\n        )\n\n\n\n    from \"claire\".\"dbt_claire\".\"segment_web_sessions\"\n)\n\n\n    group by 1\n\n),\n\n\n\nwindowed as (\n\n    select\n\n        *,\n\n        row_number() over (\n            partition by blended_user_id\n            order by sessions.session_start_tstamp\n            )\n            + coalesce(agg.starting_session_number, 0) \n            as session_number\n\n    from sessions\n\n    \n    left join agg using (blended_user_id)\n    \n\n\n)\n\nselect * from windowed", "extra_ctes_injected": true, "extra_ctes": [], "injected_sql": "\n\n\n\n\n\nwith sessions as (\n\n    select * from \"claire\".\"dbt_claire\".\"segment_web_sessions__stitched\"\n\n    \n    where cast(session_start_tstamp as datetime) > \n(\n    select\n        \n  \n\n    dateadd(\n        hour,\n        -3,\n        max(session_start_tstamp)\n        )\n\n\n\n    from \"claire\".\"dbt_claire\".\"segment_web_sessions\"\n)\n\n    \n\n),\n\n\n\nagg as (\n\n    select\n        blended_user_id,\n        count(*) as starting_session_number\n    from \"claire\".\"dbt_claire\".\"segment_web_sessions\"\n\n    -- only include sessions that are not going to be resessionized in this run\n    where cast(session_start_tstamp as datetime) <= \n(\n    select\n        \n  \n\n    dateadd(\n        hour,\n        -3,\n        max(session_start_tstamp)\n        )\n\n\n\n    from \"claire\".\"dbt_claire\".\"segment_web_sessions\"\n)\n\n\n    group by 1\n\n),\n\n\n\nwindowed as (\n\n    select\n\n        *,\n\n        row_number() over (\n            partition by blended_user_id\n            order by sessions.session_start_tstamp\n            )\n            + coalesce(agg.starting_session_number, 0) \n            as session_number\n\n    from sessions\n\n    \n    left join agg using (blended_user_id)\n    \n\n\n)\n\nselect * from windowed", "wrapped_sql": null}, "error": null, "status": null, "execution_time": 0.6369040012359619, "thread_id": "Thread-1", "timing": [{"name": "compile", "started_at": "2020-03-26T18:15:28.797528Z", "completed_at": "2020-03-26T18:15:29.395629Z"}, {"name": "execute", "started_at": "2020-03-26T18:15:29.395963Z", "completed_at": "2020-03-26T18:15:29.395973Z"}], "fail": null, "warn": null, "skip": false}, {"node": {"raw_sql": "{{ config(severity='ERROR') }}{{ test_not_null(model=ref('segment_web_sessions__stitched'), column_name='session_id') }}", "database": "claire", "schema": "dbt_claire", "fqn": ["segment", "schema_test", "not_null_segment_web_sessions__stitched_session_id"], "unique_id": "test.segment.not_null_segment_web_sessions__stitched_session_id", "package_name": "segment", "root_path": "/Users/claire/fishtown/packages/segment/integration_tests/dbt_modules/segment", "path": "schema_test/not_null_segment_web_sessions__stitched_session_id.sql", "original_file_path": "models/sessionization/schema.yml", "name": "not_null_segment_web_sessions__stitched_session_id", "resource_type": "test", "alias": "not_null_segment_web_sessions__stitched_session_id", "config": {"enabled": true, "materialized": "view", "persist_docs": {}, "post-hook": [], "pre-hook": [], "vars": {"segment_page_views_table": "{{ ref('example_segment_pages') }}", "segment_sessionization_trailing_window": 3, "segment_inactivity_cutoff": "30 * 60", "segment_pass_through_columns": []}, "quoting": {}, "column_types": {}, "tags": [], "severity": "ERROR"}, "tags": ["schema"], "refs": [["segment_web_sessions__stitched"]], "sources": [], "depends_on": {"macros": ["macro.dbt.test_not_null"], "nodes": ["model.segment.segment_web_sessions__stitched"]}, "description": "", "columns": {}, "meta": {}, "docs": {"show": true}, "patch_path": null, "build_path": "target/compiled/segment/schema_test/not_null_segment_web_sessions__stitched_session_id.sql", "compiled": true, "compiled_sql": "\n\n\n\nselect count(*)\nfrom \"claire\".\"dbt_claire\".\"segment_web_sessions__stitched\"\nwhere session_id is null\n\n", "extra_ctes_injected": true, "extra_ctes": [], "injected_sql": "\n\n\n\nselect count(*)\nfrom \"claire\".\"dbt_claire\".\"segment_web_sessions__stitched\"\nwhere session_id is null\n\n", "wrapped_sql": "\n\n\n\nselect count(*)\nfrom \"claire\".\"dbt_claire\".\"segment_web_sessions__stitched\"\nwhere session_id is null\n\n", "column_name": "session_id", "test_metadata": {"namespace": null, "name": "not_null", "kwargs": {"column_name": "session_id"}}}, "error": null, "status": null, "execution_time": 0.013588905334472656, "thread_id": "Thread-1", "timing": [{"name": "compile", "started_at": "2020-03-26T18:15:29.435457Z", "completed_at": "2020-03-26T18:15:29.447465Z"}, {"name": "execute", "started_at": "2020-03-26T18:15:29.447773Z", "completed_at": "2020-03-26T18:15:29.447783Z"}], "fail": null, "warn": null, "skip": false}, {"node": {"raw_sql": "{{ config(severity='ERROR') }}{{ test_unique(model=ref('segment_web_sessions__stitched'), column_name='session_id') }}", "database": "claire", "schema": "dbt_claire", "fqn": ["segment", "schema_test", "unique_segment_web_sessions__stitched_session_id"], "unique_id": "test.segment.unique_segment_web_sessions__stitched_session_id", "package_name": "segment", "root_path": "/Users/claire/fishtown/packages/segment/integration_tests/dbt_modules/segment", "path": "schema_test/unique_segment_web_sessions__stitched_session_id.sql", "original_file_path": "models/sessionization/schema.yml", "name": "unique_segment_web_sessions__stitched_session_id", "resource_type": "test", "alias": "unique_segment_web_sessions__stitched_session_id", "config": {"enabled": true, "materialized": "view", "persist_docs": {}, "post-hook": [], "pre-hook": [], "vars": {"segment_page_views_table": "{{ ref('example_segment_pages') }}", "segment_sessionization_trailing_window": 3, "segment_inactivity_cutoff": "30 * 60", "segment_pass_through_columns": []}, "quoting": {}, "column_types": {}, "tags": [], "severity": "ERROR"}, "tags": ["schema"], "refs": [["segment_web_sessions__stitched"]], "sources": [], "depends_on": {"macros": ["macro.dbt.test_unique"], "nodes": ["model.segment.segment_web_sessions__stitched"]}, "description": "", "columns": {}, "meta": {}, "docs": {"show": true}, "patch_path": null, "build_path": "target/compiled/segment/schema_test/unique_segment_web_sessions__stitched_session_id.sql", "compiled": true, "compiled_sql": "\n\n\n\nselect count(*)\nfrom (\n\n    select\n        session_id\n\n    from \"claire\".\"dbt_claire\".\"segment_web_sessions__stitched\"\n    where session_id is not null\n    group by session_id\n    having count(*) > 1\n\n) validation_errors\n\n", "extra_ctes_injected": true, "extra_ctes": [], "injected_sql": "\n\n\n\nselect count(*)\nfrom (\n\n    select\n        session_id\n\n    from \"claire\".\"dbt_claire\".\"segment_web_sessions__stitched\"\n    where session_id is not null\n    group by session_id\n    having count(*) > 1\n\n) validation_errors\n\n", "wrapped_sql": "\n\n\n\nselect count(*)\nfrom (\n\n    select\n        session_id\n\n    from \"claire\".\"dbt_claire\".\"segment_web_sessions__stitched\"\n    where session_id is not null\n    group by session_id\n    having count(*) > 1\n\n) validation_errors\n\n", "column_name": "session_id", "test_metadata": {"namespace": null, "name": "unique", "kwargs": {"column_name": "session_id"}}}, "error": null, "status": null, "execution_time": 0.01448512077331543, "thread_id": "Thread-1", "timing": [{"name": "compile", "started_at": "2020-03-26T18:15:29.449023Z", "completed_at": "2020-03-26T18:15:29.461603Z"}, {"name": "execute", "started_at": "2020-03-26T18:15:29.462189Z", "completed_at": "2020-03-26T18:15:29.462203Z"}], "fail": null, "warn": null, "skip": false}, {"node": {"raw_sql": "{#-\n-- When compiled, the following query can be used in Mode to calculate the\n-- metrics required for an audience overview similar to the one found in GA.\n-- Since the Liquid `form` tag looks similar to a Jinja tag, dbt is erroring\n-- when compiling as `form` is an unknown tag in Jinja (even when it is wrapped\n-- in a `raw` tag).\n-- As a result, when adding to Mode, replace the comments with the correct tags.\n-#}\n\nwith source as (\n    \n    select * from {{ref('segment_web_sessions')}}\n    \n)\n\n, final as (\n    \n    select\n        date_trunc({% raw %}'{{date_part}}'{% endraw %}, session_start_tstamp)::date as period,\n        \n        count(*) as sessions,\n        count(distinct blended_user_id) as distinct_users,\n        sum(page_views) as page_views,\n        1.0 * sum(page_views) / nullif(count(*), 0) as pages_per_session,\n        avg(duration_in_s) as avg_session_duration,\n        1.0 * sum(case when page_views = 1 then 1 else 0 end) /\n            nullif(count(*), 0) as bounce_rate,\n        sum(case when session_number = 1 then 1 else 0 end) as new_sessions,\n        sum(case when session_number > 1 then 1 else 0 end) as repeat_sessions\n\n    from source\n        \n    where session_start_tstamp >= '{% raw %}{{start_date}}{% endraw %}'\n      and session_start_tstamp <  '{% raw %}{{end_date}}{% endraw %}'\n     \n    group by 1\n    \n)\n\nselect * from final\n\n-- A form tag needs to go here\n\ndate_part:\n    type: select\n    default: day\n    options: [hour, day, week, month]\n\nstart_date:\n    type: date\n    default: 2018-11-01\n\nend_date:\n    type: date\n    default: 2018-12-01\n\n-- An endform tag needs to go here", "database": "claire", "schema": "dbt_claire", "fqn": ["segment", "analysis", "mode_queries", "audience_overview"], "unique_id": "analysis.segment.audience_overview", "package_name": "segment", "root_path": "/Users/claire/fishtown/packages/segment/integration_tests/dbt_modules/segment", "path": "analysis/mode_queries/audience_overview.sql", "original_file_path": "analysis/mode_queries/audience_overview.sql", "name": "audience_overview", "resource_type": "analysis", "alias": "audience_overview", "config": {"enabled": true, "materialized": "view", "persist_docs": {}, "post-hook": [], "pre-hook": [], "vars": {"segment_page_views_table": "{{ ref('example_segment_pages') }}", "segment_sessionization_trailing_window": 3, "segment_inactivity_cutoff": "30 * 60", "segment_pass_through_columns": []}, "quoting": {}, "column_types": {}, "tags": []}, "tags": [], "refs": [["segment_web_sessions"]], "sources": [], "depends_on": {"macros": [], "nodes": ["model.segment.segment_web_sessions"]}, "description": "", "columns": {}, "meta": {}, "docs": {"show": true}, "patch_path": null, "build_path": "target/compiled/segment/analysis/mode_queries/audience_overview.sql", "compiled": true, "compiled_sql": "with source as (\n    \n    select * from \"claire\".\"dbt_claire\".\"segment_web_sessions\"\n    \n)\n\n, final as (\n    \n    select\n        date_trunc('{{date_part}}', session_start_tstamp)::date as period,\n        \n        count(*) as sessions,\n        count(distinct blended_user_id) as distinct_users,\n        sum(page_views) as page_views,\n        1.0 * sum(page_views) / nullif(count(*), 0) as pages_per_session,\n        avg(duration_in_s) as avg_session_duration,\n        1.0 * sum(case when page_views = 1 then 1 else 0 end) /\n            nullif(count(*), 0) as bounce_rate,\n        sum(case when session_number = 1 then 1 else 0 end) as new_sessions,\n        sum(case when session_number > 1 then 1 else 0 end) as repeat_sessions\n\n    from source\n        \n    where session_start_tstamp >= '{{start_date}}'\n      and session_start_tstamp <  '{{end_date}}'\n     \n    group by 1\n    \n)\n\nselect * from final\n\n-- A form tag needs to go here\n\ndate_part:\n    type: select\n    default: day\n    options: [hour, day, week, month]\n\nstart_date:\n    type: date\n    default: 2018-11-01\n\nend_date:\n    type: date\n    default: 2018-12-01\n\n-- An endform tag needs to go here", "extra_ctes_injected": true, "extra_ctes": [], "injected_sql": "with source as (\n    \n    select * from \"claire\".\"dbt_claire\".\"segment_web_sessions\"\n    \n)\n\n, final as (\n    \n    select\n        date_trunc('{{date_part}}', session_start_tstamp)::date as period,\n        \n        count(*) as sessions,\n        count(distinct blended_user_id) as distinct_users,\n        sum(page_views) as page_views,\n        1.0 * sum(page_views) / nullif(count(*), 0) as pages_per_session,\n        avg(duration_in_s) as avg_session_duration,\n        1.0 * sum(case when page_views = 1 then 1 else 0 end) /\n            nullif(count(*), 0) as bounce_rate,\n        sum(case when session_number = 1 then 1 else 0 end) as new_sessions,\n        sum(case when session_number > 1 then 1 else 0 end) as repeat_sessions\n\n    from source\n        \n    where session_start_tstamp >= '{{start_date}}'\n      and session_start_tstamp <  '{{end_date}}'\n     \n    group by 1\n    \n)\n\nselect * from final\n\n-- A form tag needs to go here\n\ndate_part:\n    type: select\n    default: day\n    options: [hour, day, week, month]\n\nstart_date:\n    type: date\n    default: 2018-11-01\n\nend_date:\n    type: date\n    default: 2018-12-01\n\n-- An endform tag needs to go here", "wrapped_sql": null}, "error": null, "status": null, "execution_time": 0.024029970169067383, "thread_id": "Thread-1", "timing": [{"name": "compile", "started_at": "2020-03-26T18:15:29.465299Z", "completed_at": "2020-03-26T18:15:29.486817Z"}, {"name": "execute", "started_at": "2020-03-26T18:15:29.487246Z", "completed_at": "2020-03-26T18:15:29.487256Z"}], "fail": null, "warn": null, "skip": false}, {"node": {"raw_sql": "{{ config(severity='ERROR') }}{{ test_not_null(model=ref('segment_web_sessions'), column_name='session_id') }}", "database": "claire", "schema": "dbt_claire", "fqn": ["segment", "schema_test", "not_null_segment_web_sessions_session_id"], "unique_id": "test.segment.not_null_segment_web_sessions_session_id", "package_name": "segment", "root_path": "/Users/claire/fishtown/packages/segment/integration_tests/dbt_modules/segment", "path": "schema_test/not_null_segment_web_sessions_session_id.sql", "original_file_path": "models/sessionization/schema.yml", "name": "not_null_segment_web_sessions_session_id", "resource_type": "test", "alias": "not_null_segment_web_sessions_session_id", "config": {"enabled": true, "materialized": "view", "persist_docs": {}, "post-hook": [], "pre-hook": [], "vars": {"segment_page_views_table": "{{ ref('example_segment_pages') }}", "segment_sessionization_trailing_window": 3, "segment_inactivity_cutoff": "30 * 60", "segment_pass_through_columns": []}, "quoting": {}, "column_types": {}, "tags": [], "severity": "ERROR"}, "tags": ["schema"], "refs": [["segment_web_sessions"]], "sources": [], "depends_on": {"macros": ["macro.dbt.test_not_null"], "nodes": ["model.segment.segment_web_sessions"]}, "description": "", "columns": {}, "meta": {}, "docs": {"show": true}, "patch_path": null, "build_path": "target/compiled/segment/schema_test/not_null_segment_web_sessions_session_id.sql", "compiled": true, "compiled_sql": "\n\n\n\nselect count(*)\nfrom \"claire\".\"dbt_claire\".\"segment_web_sessions\"\nwhere session_id is null\n\n", "extra_ctes_injected": true, "extra_ctes": [], "injected_sql": "\n\n\n\nselect count(*)\nfrom \"claire\".\"dbt_claire\".\"segment_web_sessions\"\nwhere session_id is null\n\n", "wrapped_sql": "\n\n\n\nselect count(*)\nfrom \"claire\".\"dbt_claire\".\"segment_web_sessions\"\nwhere session_id is null\n\n", "column_name": "session_id", "test_metadata": {"namespace": null, "name": "not_null", "kwargs": {"column_name": "session_id"}}}, "error": null, "status": null, "execution_time": 0.013254165649414062, "thread_id": "Thread-1", "timing": [{"name": "compile", "started_at": "2020-03-26T18:15:29.488592Z", "completed_at": "2020-03-26T18:15:29.500706Z"}, {"name": "execute", "started_at": "2020-03-26T18:15:29.500976Z", "completed_at": "2020-03-26T18:15:29.500984Z"}], "fail": null, "warn": null, "skip": false}, {"node": {"raw_sql": "{{ config(severity='ERROR') }}{{ test_unique(model=ref('segment_web_sessions'), column_name='session_id') }}", "database": "claire", "schema": "dbt_claire", "fqn": ["segment", "schema_test", "unique_segment_web_sessions_session_id"], "unique_id": "test.segment.unique_segment_web_sessions_session_id", "package_name": "segment", "root_path": "/Users/claire/fishtown/packages/segment/integration_tests/dbt_modules/segment", "path": "schema_test/unique_segment_web_sessions_session_id.sql", "original_file_path": "models/sessionization/schema.yml", "name": "unique_segment_web_sessions_session_id", "resource_type": "test", "alias": "unique_segment_web_sessions_session_id", "config": {"enabled": true, "materialized": "view", "persist_docs": {}, "post-hook": [], "pre-hook": [], "vars": {"segment_page_views_table": "{{ ref('example_segment_pages') }}", "segment_sessionization_trailing_window": 3, "segment_inactivity_cutoff": "30 * 60", "segment_pass_through_columns": []}, "quoting": {}, "column_types": {}, "tags": [], "severity": "ERROR"}, "tags": ["schema"], "refs": [["segment_web_sessions"]], "sources": [], "depends_on": {"macros": ["macro.dbt.test_unique"], "nodes": ["model.segment.segment_web_sessions"]}, "description": "", "columns": {}, "meta": {}, "docs": {"show": true}, "patch_path": null, "build_path": "target/compiled/segment/schema_test/unique_segment_web_sessions_session_id.sql", "compiled": true, "compiled_sql": "\n\n\n\nselect count(*)\nfrom (\n\n    select\n        session_id\n\n    from \"claire\".\"dbt_claire\".\"segment_web_sessions\"\n    where session_id is not null\n    group by session_id\n    having count(*) > 1\n\n) validation_errors\n\n", "extra_ctes_injected": true, "extra_ctes": [], "injected_sql": "\n\n\n\nselect count(*)\nfrom (\n\n    select\n        session_id\n\n    from \"claire\".\"dbt_claire\".\"segment_web_sessions\"\n    where session_id is not null\n    group by session_id\n    having count(*) > 1\n\n) validation_errors\n\n", "wrapped_sql": "\n\n\n\nselect count(*)\nfrom (\n\n    select\n        session_id\n\n    from \"claire\".\"dbt_claire\".\"segment_web_sessions\"\n    where session_id is not null\n    group by session_id\n    having count(*) > 1\n\n) validation_errors\n\n", "column_name": "session_id", "test_metadata": {"namespace": null, "name": "unique", "kwargs": {"column_name": "session_id"}}}, "error": null, "status": null, "execution_time": 0.011534929275512695, "thread_id": "Thread-1", "timing": [{"name": "compile", "started_at": "2020-03-26T18:15:29.501946Z", "completed_at": "2020-03-26T18:15:29.512185Z"}, {"name": "execute", "started_at": "2020-03-26T18:15:29.512634Z", "completed_at": "2020-03-26T18:15:29.512646Z"}], "fail": null, "warn": null, "skip": false}], "generated_at": "2020-03-26T18:15:29.519252Z", "elapsed_time": 2.399125099182129}